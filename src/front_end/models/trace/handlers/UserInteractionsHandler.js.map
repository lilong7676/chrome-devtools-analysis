{"version":3,"file":"UserInteractionsHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/UserInteractionsHandler.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,OAAO,MAAM,uBAAuB,CAAC;AACjD,OAAO,KAAK,KAAK,MAAM,mBAAmB,CAAC;AAI3C,2EAA2E;AAC3E,sEAAsE;AACtE,wEAAwE;AACxE,2DAA2D;AAE3D,yEAAyE;AACzE,0EAA0E;AAC1E,MAAM,SAAS,GAA8C,EAAE,CAAC;AAYhE,MAAM,iBAAiB,GAAuB,EAAE,CAAC;AAEjD,IAAI,YAAY,qCAA6B,CAAC;AAC9C,MAAM,UAAU,KAAK;IACnB,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC;IACrB,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC;IAC7B,YAAY,mCAA2B,CAAC;AAC1C,CAAC;AAED,MAAM,UAAU,WAAW,CAAC,KAAuC;IACjE,IAAI,YAAY,qCAA6B,EAAE;QAC7C,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;KAC/C;IAED,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,uBAAuB,CAAC,KAAK,CAAC,EAAE;QACrD,OAAO;KACR;IAED,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAEtB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE;QACpB,OAAO;KACR;IACD,MAAM,EAAC,QAAQ,EAAE,aAAa,EAAC,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;IAClD,qDAAqD;IACrD,4BAA4B;IAC5B,gCAAgC;IAChC,sEAAsE;IACtE,gFAAgF;IAChF,4CAA4C;IAC5C,oLAAoL;IAEpL,IAAI,QAAQ,GAAG,CAAC,IAAI,aAAa,KAAK,SAAS,IAAI,aAAa,KAAK,CAAC,EAAE;QACtE,OAAO;KACR;IAED,MAAM,gBAAgB,GAAqB;QACzC,GAAG,KAAK;QACR,qEAAqE;QACrE,aAAa;QACb,iEAAiE;QACjE,6EAA6E;QAC7E,2EAA2E;QAC3E,2EAA2E;QAC3E,GAAG,EAAE,OAAO,CAAC,MAAM,CAAC,0BAA0B,CAAC,QAAQ,CAAC;KACzD,CAAC;IAEF,iBAAiB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;AAC3C,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,QAAQ;IAC5B,YAAY,iCAAyB,CAAC;AACxC,CAAC;AAED,MAAM,UAAU,IAAI;IAClB,OAAO;QACL,SAAS,EAAE,CAAC,GAAG,SAAS,CAAC;QACzB,iBAAiB,EAAE,CAAC,GAAG,iBAAiB,CAAC;KAC1C,CAAC;AACJ,CAAC","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {HandlerState} from './types.js';\n\n// This handler serves two purposes. It generates a list of evnets that are\n// used to show user clicks in the timeline. It is also used to gather\n// EventTimings into Interactions, which we use to show interactions and\n// highlight long interactions to the user, along with INP.\n\n// We don't need to know which process / thread these events occurred in,\n// because they are effectively global, so we just track all that we find.\nconst allEvents: Types.TraceEvents.TraceEventEventTiming[] = [];\n\nexport interface UserInteractionsData {\n  allEvents: readonly Types.TraceEvents.TraceEventEventTiming[];\n  interactionEvents: readonly InteractionEvent[];\n}\n\nexport interface InteractionEvent extends Types.TraceEvents.TraceEventEventTiming {\n  dur: Types.Timing.MicroSeconds;\n  interactionId: number;\n}\n\nconst interactionEvents: InteractionEvent[] = [];\n\nlet handlerState = HandlerState.UNINITIALIZED;\nexport function reset(): void {\n  allEvents.length = 0;\n  interactionEvents.length = 0;\n  handlerState = HandlerState.INITIALIZED;\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Handler is not initialized');\n  }\n\n  if (!Types.TraceEvents.isTraceEventEventTiming(event)) {\n    return;\n  }\n\n  allEvents.push(event);\n\n  if (!event.args.data) {\n    return;\n  }\n  const {duration, interactionId} = event.args.data;\n  // We exclude events for the sake of interactions if:\n  // 1. They have no duration.\n  // 2. They have no interactionId\n  // 3. They have an interactionId of 0: this indicates that it's not an\n  //    interaction that we care about because it hasn't had its own interactionId\n  //    set (0 is the default on the backend).\n  // See: https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/responsiveness_metrics.cc;l=133;drc=40c209a9c365ebb9f16fb99dfe78c7fe768b9594\n\n  if (duration < 1 || interactionId === undefined || interactionId === 0) {\n    return;\n  }\n\n  const interactionEvent: InteractionEvent = {\n    ...event,\n    // We also store the interactionId on the top level for easier access\n    interactionId,\n    // EventTiming events do not have a duration, but ones we use for\n    // Interactions do, in args.data.duration. But that value is in milliseconds.\n    // To avoid confusion and accidental bad maths adding micro + milliseconds,\n    // we set `dur` to the MicroSeconds value here before returning the events.\n    dur: Helpers.Timing.millisecondsToMicroseconds(duration),\n  };\n\n  interactionEvents.push(interactionEvent);\n}\n\nexport async function finalize(): Promise<void> {\n  handlerState = HandlerState.FINALIZED;\n}\n\nexport function data(): UserInteractionsData {\n  return {\n    allEvents: [...allEvents],\n    interactionEvents: [...interactionEvents],\n  };\n}\n"]}