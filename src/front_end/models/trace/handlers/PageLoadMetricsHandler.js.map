{"version":3,"file":"PageLoadMetricsHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/PageLoadMetricsHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\n\nimport * as Helpers from '../helpers/helpers.js';\nimport {KnownEventName, type TraceEventHandlerName, type HandlerData, type Handlers} from './types.js';\n\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport {data as rendererHandlerData} from './RendererHandler.js';\n\n/**\n * This represents the metric scores for all navigations, for all frames in a trace.\n * Given a frame id, the map points to another map from navigation id to metric scores.\n * The metric scores include the event related to the metric as well as the data regarding\n * the score itself.\n */\nconst metricScoresByFrameId = new Map<string, Map<string, Map<MetricName, MetricScore>>>();\n\nexport function reset(): void {\n  metricScoresByFrameId.clear();\n  pageLoadEventsArray = [];\n  selectedLCPCandidateEvents.clear();\n}\n\nlet pageLoadEventsArray: Types.TraceEvents.PageLoadEvent[] = [];\n\n// Once we've found the LCP events in the trace we want to fetch their DOM Node\n// from the backend. We could do this by parsing through our Map of frame =>\n// navigation => metric, but it's easier to keep a set of LCP events. As we\n// parse the trace, any time we store an LCP candidate as the potential LCP\n// event, we store the event here. If we later find a new candidate in the\n// trace, we store that and delete the prior event. When we've parsed the\n// entire trace this set will contain all the LCP events that were used - e.g.\n// the candidates that were the actual LCP events.\nconst selectedLCPCandidateEvents = new Set<Types.TraceEvents.TraceEventLargestContentfulPaintCandidate>();\n\nfunction eventIsPageLoadEvent(event: Types.TraceEvents.TraceEventData): event is Types.TraceEvents.PageLoadEvent {\n  return Types.TraceEvents.isTraceEventFirstContentfulPaint(event) ||\n      Types.TraceEvents.isTraceEventMarkDOMContent(event) || Types.TraceEvents.isTraceEventInteractiveTime(event) ||\n      Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(event);\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (!eventIsPageLoadEvent(event)) {\n    return;\n  }\n  pageLoadEventsArray.push(event);\n}\n\nfunction storePageLoadMetricAgainstNavigationId(\n    navigation: Types.TraceEvents.TraceEventNavigationStart, event: Types.TraceEvents.PageLoadEvent): void {\n  const navigationId = navigation.args.data?.navigationId;\n  if (!navigationId) {\n    throw new Error('Navigation event unexpectedly had no navigation ID.');\n  }\n  const frameId = getFrameIdForPageLoadEvent(event);\n  const {rendererProcessesByFrame} = metaHandlerData();\n  const processData = rendererProcessesByFrame.get(frameId)?.get(event.pid);\n  if (!processData) {\n    throw new Error('No processes found for page load event.');\n  }\n\n  // We compare the timestamp of the event to determine if it happened during the\n  // time window in which its process was considered active.\n  const eventBelongsToProcess = event.ts >= processData.window.min && event.ts <= processData.window.max;\n\n  if (!eventBelongsToProcess) {\n    // If the event occurred outside its process' active time window we ignore it.\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventFirstContentfulPaint(event)) {\n    const fcpTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const score = Helpers.Timing.formatMicrosecondsTime(fcpTime, {\n      format: Types.Timing.TimeUnit.SECONDS,\n      maximumFractionDigits: 2,\n    });\n    const classification = scoreClassificationForFirstContentfulPaint(fcpTime);\n    const metricScore = {event, score, metricName: MetricName.FCP, classification, navigation};\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventMarkDOMContent(event)) {\n    const dclTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const score = Helpers.Timing.formatMicrosecondsTime(dclTime, {\n      format: Types.Timing.TimeUnit.SECONDS,\n      maximumFractionDigits: 2,\n    });\n    const metricScore = {\n      event,\n      score,\n      metricName: MetricName.DCL,\n      classification: scoreClassificationForDOMContentLoaded(dclTime),\n      navigation,\n    };\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventInteractiveTime(event)) {\n    const ttiValue = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const ttiScore = Helpers.Timing.formatMicrosecondsTime(ttiValue, {\n      format: Types.Timing.TimeUnit.SECONDS,\n      maximumFractionDigits: 2,\n    });\n    const tti = {\n      event,\n      score: ttiScore,\n      metricName: MetricName.TTI,\n      classification: scoreClassificationForTimeToInteractive(ttiValue),\n      navigation,\n    };\n    storeMetricScore(frameId, navigationId, tti);\n\n    const tbtValue =\n        Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(event.args.args.total_blocking_time_ms));\n    const tbtScore = Helpers.Timing.formatMicrosecondsTime(tbtValue, {\n      format: Types.Timing.TimeUnit.MILLISECONDS,\n      maximumFractionDigits: 2,\n    });\n    const tbt = {\n      event,\n      score: tbtScore,\n      metricName: MetricName.TBT,\n      classification: scoreClassificationForTotalBlockingTime(tbtValue),\n      navigation,\n    };\n    storeMetricScore(frameId, navigationId, tbt);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(event)) {\n    const candidateIndex = event.args.data?.candidateIndex;\n    if (!candidateIndex) {\n      throw new Error('Largest Contenful Paint unexpectedly had no candidateIndex.');\n    }\n    const lcpTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const lcpScore = Helpers.Timing.formatMicrosecondsTime(lcpTime, {\n      format: Types.Timing.TimeUnit.SECONDS,\n      maximumFractionDigits: 2,\n    });\n    const lcp = {\n      event,\n      score: lcpScore,\n      metricName: MetricName.LCP,\n      classification: scoreClassificationForLargestContentfulPaint(lcpTime),\n      navigation,\n    };\n    const metricsByNavigation = Platform.MapUtilities.getWithDefault(metricScoresByFrameId, frameId, () => new Map());\n    const metrics = Platform.MapUtilities.getWithDefault(metricsByNavigation, navigationId, () => new Map());\n    const lastLCPCandidate = metrics.get(MetricName.LCP);\n    if (lastLCPCandidate === undefined) {\n      selectedLCPCandidateEvents.add(lcp.event);\n      storeMetricScore(frameId, navigationId, lcp);\n      return;\n    }\n    const lastLCPCandidateEvent = lastLCPCandidate.event;\n\n    if (!Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(lastLCPCandidateEvent)) {\n      return;\n    }\n    const lastCandidateIndex = lastLCPCandidateEvent.args.data?.candidateIndex;\n    if (!lastCandidateIndex) {\n      // lastCandidateIndex cannot be undefined because don't store candidates with\n      // with an undefined candidateIndex value. This check is only to make TypeScript\n      // treat the field as not undefined below.\n      return;\n    }\n    if (lastCandidateIndex < candidateIndex) {\n      selectedLCPCandidateEvents.delete(lastLCPCandidateEvent);\n      selectedLCPCandidateEvents.add(lcp.event);\n      storeMetricScore(frameId, navigationId, lcp);\n    }\n    return;\n  }\n  if (Types.TraceEvents.isTraceEventLayoutShift(event)) {\n    return;\n  }\n  return Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\nfunction storeMetricScore(frameId: string, navigationId: string, metricScore: MetricScore): void {\n  const metricsByNavigation = Platform.MapUtilities.getWithDefault(metricScoresByFrameId, frameId, () => new Map());\n  const metrics = Platform.MapUtilities.getWithDefault(metricsByNavigation, navigationId, () => new Map());\n  // If an entry with that metric name is present, delete it so that the new entry that\n  // will replace it is added at the end of the map. This way we guarantee the map entries\n  // are ordered in ASC manner by timestamp.\n  metrics.delete(metricScore.metricName);\n  metrics.set(metricScore.metricName, metricScore);\n}\n\nfunction getFrameIdForPageLoadEvent(event: Types.TraceEvents.PageLoadEvent): string {\n  if (Types.TraceEvents.isTraceEventFirstContentfulPaint(event) ||\n      Types.TraceEvents.isTraceEventInteractiveTime(event) ||\n      Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(event) ||\n      Types.TraceEvents.isTraceEventLayoutShift(event)) {\n    return event.args.frame;\n  }\n  if (Types.TraceEvents.isTraceEventMarkDOMContent(event)) {\n    const frameId = event.args.data?.frame;\n    if (!frameId) {\n      throw new Error('MarkDOMContent unexpectedly had no frame ID.');\n    }\n    return frameId;\n  }\n  Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\nfunction getNavigationForPageLoadEvent(event: Types.TraceEvents.PageLoadEvent):\n    Types.TraceEvents.TraceEventNavigationStart|null {\n  if (Types.TraceEvents.isTraceEventFirstContentfulPaint(event) ||\n      Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(event)) {\n    const navigationId = event.args.data?.navigationId;\n    if (!navigationId) {\n      throw new Error('Trace event unexpectedly had no navigation ID.');\n    }\n    const {navigationsByNavigationId} = metaHandlerData();\n    const navigation = navigationsByNavigationId.get(navigationId);\n\n    if (!navigation) {\n      // This event's navigation has been filtered out by the meta handler as a noise event.\n      return null;\n    }\n    return navigation;\n  }\n\n  if (Types.TraceEvents.isTraceEventMarkDOMContent(event) || Types.TraceEvents.isTraceEventInteractiveTime(event) ||\n      Types.TraceEvents.isTraceEventLayoutShift(event)) {\n    const frameId = getFrameIdForPageLoadEvent(event);\n    const {navigationsByFrameId} = metaHandlerData();\n    return Helpers.Trace.getNavigationForTraceEvent(event, frameId, navigationsByFrameId);\n  }\n\n  return Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\n/**\n * This methods calculates the Total Blocking Time for navigations for which\n * an InteractiveTime event wasn't recorded, that is, navigations without a\n * TBT reported by the backend. This could happen for example if the user\n * stops the recording before the page has settled. Although TBT is officially\n * the sum of the blocking portion of all long tasks between FCP and TTI, we\n * can still report the blocking time between FCP and the instant the recording\n * was stopped, in case TTI wasn't reached.\n */\nfunction estimateTotalBlockingTimes(): void {\n  const {processes} = rendererHandlerData();\n  const LONG_TASK_THRESHOLD = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(50));\n  for (const [frameId, metricsByNavigation] of metricScoresByFrameId) {\n    for (const [navigationId, metrics] of metricsByNavigation) {\n      const navigationTBT = metrics.get(MetricName.TBT);\n      const navigationFCP = metrics.get(MetricName.FCP);\n      if (navigationTBT || !navigationFCP) {\n        // Either a TBT record was reported for this navigation so we don't\n        // need to estimate its value, or FCP wasn't reached so we can't\n        // estimate it.\n        continue;\n      }\n      if (!navigationFCP.event) {\n        continue;\n      }\n\n      // Get Main Thread information\n      const renderer = processes.get(navigationFCP.event.pid);\n      if (!renderer) {\n        // This can happen if the navigation was on a process that had no\n        // origin, or an origin we discard, such as about:blank. In this case\n        // we can discard the navigation as it's not relevant and we don't need\n        // to use it to calculate TBT.\n        continue;\n      }\n      const mainThread = [...renderer.threads.values()].find(thread => thread.name === 'CrRendererMain');\n      const mainThreadTree = mainThread?.tree;\n      if (!mainThread || !mainThreadTree) {\n        throw new Error('Main thread not found.');\n      }\n      const mainThreadEvents = mainThread.events;\n      const mainThreadNodes = mainThreadTree.nodes;\n      const fcpTs = navigationFCP.event.ts;\n      // Calulate TBT from Main Thread tasks.\n      let tbt = 0;\n      for (const rootId of mainThreadTree.roots) {\n        const node = mainThreadNodes.get(rootId);\n        if (node === undefined) {\n          throw new Error(`Node not found for id: ${rootId}`);\n        }\n        if (mainThreadEvents[node.eventIndex] === undefined) {\n          throw new Error(`Event not found for index: ${node.eventIndex}`);\n        }\n        const task = mainThreadEvents[node.eventIndex];\n        if (task.name !== KnownEventName.RunTask || Types.TraceEvents.isTraceEventInstant(task)) {\n          continue;\n        }\n\n        // Discard event if it ended before FCP.\n        if (task.ts + task.dur < fcpTs) {\n          continue;\n        }\n\n        // Following Lighthouse guidance, get the portion of the task occured after FCP\n        // before calculating its blocking portion (because tasks before FCP are\n        // unimportant, we consider only the blocking time after FCP).\n        const timeAfterFCP = task.ts < fcpTs ? fcpTs - task.ts : 0;\n        const clippedTaskDuration = task.dur - timeAfterFCP;\n        tbt += clippedTaskDuration > LONG_TASK_THRESHOLD ? clippedTaskDuration - LONG_TASK_THRESHOLD : 0;\n      }\n\n      const tbtValue = Types.Timing.MicroSeconds(tbt);\n      const tbtScore = Helpers.Timing.formatMicrosecondsTime(tbtValue, {\n        format: Types.Timing.TimeUnit.MILLISECONDS,\n        maximumFractionDigits: 2,\n      });\n      const tbtMetric = {\n        score: tbtScore,\n        estimated: true,\n        metricName: MetricName.TBT,\n        classification: scoreClassificationForTotalBlockingTime(tbtValue),\n        navigation: navigationFCP.navigation,\n      };\n      storeMetricScore(frameId, navigationId, tbtMetric);\n    }\n  }\n}\n\n/*\n * When we first load a new trace, rather than position the playhead at time 0,\n* we want to position it such that the thumbnail likely shows something rather\n* than a blank white page, and so that it's positioned somewhere that's useful\n* for the user.  This function takes the model data, and returns either the\n* timestamp of the first FCP event, or null if it couldn't find one.\n */\nexport function getFirstFCPTimestampFromModelData(model: HandlerData<Handlers>): Types.Timing.MicroSeconds|null {\n  const mainFrameID = model.Meta.mainFrameId;\n  const metricsForMainFrameByNavigationID = model.PageLoadMetrics.metricScoresByFrameId.get(mainFrameID);\n  if (!metricsForMainFrameByNavigationID) {\n    return null;\n  }\n\n  // Now find the first FCP event by timestamp. Events may not have the raw\n  // data including timestamp, and if so we skip that event.\n  let firstFCPEventInTimeline: Types.Timing.MicroSeconds|null = null;\n  for (const metrics of metricsForMainFrameByNavigationID.values()) {\n    const fcpMetric = metrics.get(MetricName.FCP);\n    const fcpTimestamp = fcpMetric?.event?.ts;\n    if (fcpTimestamp) {\n      if (!firstFCPEventInTimeline) {\n        firstFCPEventInTimeline = fcpTimestamp;\n      } else if (fcpTimestamp < firstFCPEventInTimeline) {\n        firstFCPEventInTimeline = fcpTimestamp;\n      }\n    }\n  }\n  return firstFCPEventInTimeline;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/fcp/\n */\n\nexport function scoreClassificationForFirstContentfulPaint(fcpScoreInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const FCP_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(1.8));\n  const FCP_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(3.0));\n  let scoreClassification = ScoreClassification.BAD;\n  if (fcpScoreInMicroseconds <= FCP_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (fcpScoreInMicroseconds <= FCP_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/interactive/#how-lighthouse-determines-your-tti-score\n */\n\nexport function scoreClassificationForTimeToInteractive(ttiTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const TTI_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(3.8));\n  const TTI_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(7.3));\n  let scoreClassification = ScoreClassification.BAD;\n  if (ttiTimeInMicroseconds <= TTI_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (ttiTimeInMicroseconds <= TTI_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/lcp/#what-is-lcp\n */\n\nexport function scoreClassificationForLargestContentfulPaint(lcpTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const LCP_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(2.5));\n  const LCP_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(4));\n  let scoreClassification = ScoreClassification.BAD;\n  if (lcpTimeInMicroseconds <= LCP_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (lcpTimeInMicroseconds <= LCP_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * DCL does not have a classification.\n */\nexport function scoreClassificationForDOMContentLoaded(_dclTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  return ScoreClassification.UNCLASSIFIED;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/lighthouse-total-blocking-#time/\n */\n\nexport function scoreClassificationForTotalBlockingTime(tbtTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const TBT_GOOD_TIMING = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(200));\n  const TBT_MEDIUM_TIMING = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(600));\n  let scoreClassification = ScoreClassification.BAD;\n  if (tbtTimeInMicroseconds <= TBT_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (tbtTimeInMicroseconds <= TBT_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\nexport async function finalize(): Promise<void> {\n  pageLoadEventsArray.sort((a, b) => a.ts - b.ts);\n\n  for (const pageLoadEvent of pageLoadEventsArray) {\n    const navigation = getNavigationForPageLoadEvent(pageLoadEvent);\n    if (navigation) {\n      // Event's navigation was not filtered out as noise.\n      storePageLoadMetricAgainstNavigationId(navigation, pageLoadEvent);\n    }\n  }\n  estimateTotalBlockingTimes();\n\n  // Now we have the final LCP candidate for each frame, let's try to fetch its\n  // DOMNode. This means that we can highlight it in the page, for example.\n  const lcpNodeIds = new Set<Protocol.DOM.BackendNodeId>();\n  for (const lcpEvent of selectedLCPCandidateEvents) {\n    if (lcpEvent.args.data) {\n      lcpNodeIds.add(lcpEvent.args.data.nodeId);\n    }\n  }\n}\n\nexport function data(): {\n  metricScoresByFrameId: Map<string, Map<string, Map<MetricName, MetricScore>>>,\n} {\n  return {\n    metricScoresByFrameId: new Map(metricScoresByFrameId),\n  };\n}\n\nexport function deps(): TraceEventHandlerName[] {\n  return ['Meta', 'Renderer'];\n}\n\nexport const enum ScoreClassification {\n  GOOD = 'good',\n  OK = 'ok',\n  BAD = 'bad',\n  // Some metrics (such as DOMContentLoaded) don't have a Good/OK/Bad classification, hence this additional entry.\n  UNCLASSIFIED = 'unclassified',\n}\n\nexport const enum MetricName {\n  FCP = 'FCP',\n  LCP = 'LCP',\n  DCL = 'DCL',\n  TTI = 'TTI',\n  TBT = 'TBT',\n  CLS = 'CLS',\n}\n\nexport interface MetricScore {\n  score: string;\n  metricName: MetricName;\n  classification: ScoreClassification;\n  event?: Types.TraceEvents.PageLoadEvent;\n  // The last navigation that occured before this metric score.\n  navigation?: Types.TraceEvents.TraceEventNavigationStart;\n  estimated?: boolean;\n}\n"]}