{"version":3,"file":"TraceProcessor.js","sourceRoot":"","sources":["../../../../../../front_end/models/trace/TraceProcessor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Handlers from './handlers/handlers.js';\nimport type * as Types from './types/types.js';\n\nimport {type TraceParseEventProgressData, TraceParseEvent} from './ModelImpl.js';\nconst enum Status {\n  IDLE = 0,\n  PARSING = 1,\n  FINISHED_PARSING = 2,\n  ERRORED_WHILE_PARSING = 3,\n}\n\nexport class TraceProcessor<ModelHandlers extends {[key: string]: Handlers.Types.TraceEventHandler}> extends\n    EventTarget {\n  readonly #traceHandlers: {[key: string]: Handlers.Types.TraceEventHandler};\n  #pauseDuration: number;\n  #pauseFrequencyMs: number;\n  #status = Status.IDLE;\n\n  constructor(traceHandlers: ModelHandlers, {pauseDuration = 20, pauseFrequencyMs = 100} = {}) {\n    super();\n\n    this.#traceHandlers = traceHandlers;\n    this.#pauseDuration = pauseDuration;\n    this.#pauseFrequencyMs = pauseFrequencyMs;\n  }\n\n  reset(): void {\n    if (this.#status === Status.PARSING) {\n      throw new Error('Trace processor can\\'t reset while parsing.');\n    }\n\n    const handlers = Object.values(this.#traceHandlers);\n    for (const handler of handlers) {\n      handler.reset();\n    }\n\n    this.#status = Status.IDLE;\n  }\n\n  async parse(traceEvents: readonly Types.TraceEvents.TraceEventData[], freshRecording = false): Promise<void> {\n    if (this.#status !== Status.IDLE) {\n      throw new Error('Trace processor can\\'t start parsing when not idle.');\n    }\n    try {\n      this.#status = Status.PARSING;\n      await this.#parse(traceEvents, freshRecording);\n      this.#status = Status.FINISHED_PARSING;\n    } catch (e) {\n      this.#status = Status.ERRORED_WHILE_PARSING;\n      throw e;\n    }\n  }\n\n  async #parse(traceEvents: readonly Types.TraceEvents.TraceEventData[], freshRecording: boolean): Promise<void> {\n    // This iterator steps through all events, periodically yielding back to the\n    // main thread to avoid blocking execution. It uses `dispatchEvent` to\n    // provide status update events, and other various bits of config like the\n    // pause duration and frequency.\n    const traceEventIterator = new TraceEventIterator(traceEvents, this.#pauseDuration, this.#pauseFrequencyMs);\n\n    // Convert to array so that we are able to iterate all handlers multiple times.\n    const sortedHandlers = [...sortHandlers(this.#traceHandlers).values()];\n    // Reset.\n    for (const handler of sortedHandlers) {\n      handler.reset();\n    }\n\n    // Initialize.\n    for (const handler of sortedHandlers) {\n      handler.initialize?.(freshRecording);\n    }\n\n    // Handle each event.\n    for await (const item of traceEventIterator) {\n      if (item.kind === IteratorItemType.STATUS_UPDATE) {\n        this.dispatchEvent(new TraceParseEvent(item.data));\n        continue;\n      }\n      for (const handler of sortedHandlers) {\n        handler.handleEvent(item.data);\n      }\n    }\n\n    // Finalize.\n    for (const handler of sortedHandlers) {\n      await handler.finalize?.();\n    }\n  }\n\n  get data(): Handlers.Types.HandlerData<ModelHandlers>|null {\n    if (this.#status !== Status.FINISHED_PARSING) {\n      return null;\n    }\n\n    const data = {};\n    for (const [name, handler] of Object.entries(this.#traceHandlers)) {\n      Object.assign(data, {[name]: handler.data()});\n    }\n\n    return data as Handlers.Types.HandlerData<ModelHandlers>;\n  }\n}\n\n/**\n * Some Handlers need data provided by others. Dependencies of a handler handler are\n * declared in the `deps` field.\n * @returns A map from trace event handler name to trace event hander whose entries\n * iterate in such a way that each handler is visited after its dependencies.\n */\nexport function sortHandlers(\n    traceHandlers: Partial<{[key in Handlers.Types.TraceEventHandlerName]: Handlers.Types.TraceEventHandler}>):\n    Map<Handlers.Types.TraceEventHandlerName, Handlers.Types.TraceEventHandler> {\n  const sortedMap = new Map<Handlers.Types.TraceEventHandlerName, Handlers.Types.TraceEventHandler>();\n  const visited = new Set<Handlers.Types.TraceEventHandlerName>();\n  const visitHandler = (handlerName: Handlers.Types.TraceEventHandlerName): void => {\n    if (sortedMap.has(handlerName)) {\n      return;\n    }\n    if (visited.has(handlerName)) {\n      let stackPath = '';\n      for (const handler of visited) {\n        if (stackPath || handler === handlerName) {\n          stackPath += `${handler}->`;\n        }\n      }\n      stackPath += handlerName;\n      throw new Error(`Found dependency cycle in trace event handlers: ${stackPath}`);\n    }\n    visited.add(handlerName);\n    const handler = traceHandlers[handlerName];\n    if (!handler) {\n      return;\n    }\n    const deps = handler.deps?.();\n    if (deps) {\n      deps.forEach(visitHandler);\n    }\n    sortedMap.set(handlerName, handler);\n  };\n\n  for (const handlerName of Object.keys(traceHandlers)) {\n    visitHandler(handlerName as Handlers.Types.TraceEventHandlerName);\n  }\n  return sortedMap;\n}\n\nconst enum IteratorItemType {\n  TRACE_EVENT = 1,\n  STATUS_UPDATE = 2,\n}\n\ntype IteratorItem = IteratorTraceEventItem|IteratorStatusUpdateItem;\n\ntype IteratorTraceEventItem = {\n  kind: IteratorItemType.TRACE_EVENT,\n  data: Types.TraceEvents.TraceEventData,\n};\n\ntype IteratorStatusUpdateItem = {\n  kind: IteratorItemType.STATUS_UPDATE,\n  data: TraceParseEventProgressData,\n};\n\nclass TraceEventIterator {\n  #time: number;\n\n  constructor(\n      private traceEvents: readonly Types.TraceEvents.TraceEventData[], private pauseDuration: number,\n      private pauseFrequencyMs: number) {\n    this.#time = performance.now();\n  }\n\n  async * [Symbol.asyncIterator](): AsyncGenerator<IteratorItem, void, void> {\n    for (let i = 0, length = this.traceEvents.length; i < length; i++) {\n      // Every so often we take a break just to render.\n      if (performance.now() - this.#time > this.pauseFrequencyMs) {\n        this.#time = performance.now();\n        // Take the opportunity to provide status update events.\n        yield {kind: IteratorItemType.STATUS_UPDATE, data: {index: i, total: length}};\n        // Wait for rendering before resuming.\n        await new Promise(resolve => setTimeout(resolve, this.pauseDuration));\n      }\n\n      yield {kind: IteratorItemType.TRACE_EVENT, data: this.traceEvents[i]};\n    }\n  }\n}\n"]}